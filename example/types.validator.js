//@flow
'use strict';
/* eslint-disable */
// Generated by flow-jsonschema from ./types.js.
// DO NOT EDIT.

const assert = require('assert');
const Ajv = require('ajv');
const ajvDefault = new Ajv();
const ajvAllErrors = new Ajv({allErrors: true});

/*::
export type A = {|bool: boolean, num: number, numLit: (1 | 20), numNull: ?number, numOpt?: number, str: string, strLit: ("a" | "bc")|};
export type B = {|arr: Array<{|bool: boolean, num: number, numLit: (1 | 20), numNull: ?number, numOpt?: number, str: string, strLit: ("a" | "bc")|}>, c: (string | number), d: (boolean | null), e: ({|a: 1, b: string|} | {|a: 2, b: number|}), f: {[zz: string]: (number | string)}, tuple: [string, number, (1 | 2)]|};
export type DoublyIndirectType3 = "d";
export type IA_exported = {|fdd: {[zz: string]: (number | string)}|};
export type IB_exported = {|zf: 3|};

type ValidationOptions = {
    allErrors?: boolean,
};
export type ValidationErrorDesc = {|
    keyword: string,
    dataPath: string,
    schemaPath: string,
    params: Object,
    message: string,
|};
*/

class ValidationError extends Error {
    /*::
    typeName: string;
    errors: ValidationErrorDesc[];
    */
    constructor(typeName/*: string*/, errors/*: ValidationErrorDesc[]*/) {
        let msg/*: string*/;
        if (errors.length > 0) {
            const err = errors[0];
            msg = typeName + err.dataPath + ': ' + err.message;
            if (err.params.additionalProperty) {
                msg += ': ' + JSON.stringify(err.params.additionalProperty);
            }
        } else {
            msg = '(no errors)';
        }
        super(msg);
        this.typeName = typeName;
        this.errors = errors;
    }
}

let g_validators = {};
let g_validatorsAllErrors = {};

// Checks whether `val` is a valid A.
function checkA(val/*: A*/, opts/*: ValidationOptions*/={})/*: boolean*/ {
    const ajv = opts.allErrors !== true ? ajvDefault : ajvAllErrors;
    const validators = opts.allErrors !== true ? g_validators : g_validatorsAllErrors;

    let validator = validators["A"];
    if (validator == null) {
        let schema = {
            "type": "object",
            "properties": {
                "bool": {
                    "type": "boolean"
                },
                "num": {
                    "type": "number"
                },
                "numLit": {
                    "anyOf": [
                        {
                            "type": "number",
                            "enum": [
                                1
                            ]
                        },
                        {
                            "type": "number",
                            "enum": [
                                20
                            ]
                        }
                    ]
                },
                "numNull": {
                    "anyOf": [
                        {
                            "type": "null"
                        },
                        {
                            "type": "number"
                        }
                    ]
                },
                "numOpt": {
                    "type": "number"
                },
                "str": {
                    "type": "string"
                },
                "strLit": {
                    "anyOf": [
                        {
                            "type": "string",
                            "enum": [
                                "a"
                            ]
                        },
                        {
                            "type": "string",
                            "enum": [
                                "bc"
                            ]
                        }
                    ]
                }
            },
            "required": [
                "bool",
                "num",
                "numLit",
                "numNull",
                "str",
                "strLit"
            ],
            "additionalProperties": false
        };
        validator = ajv.compile(schema);
        validators["A"] = validator;
    }
    let ret/*: boolean*/ = validator(val);
    assert(typeof ret === 'boolean');
    let errors/*: ?Array<ValidationErrorDesc>*/ = (validator/*: any*/).errors;
    (checkA/*: any*/).errors = errors;
    return ret;
};

// Checks whether `val` is a valid A.
// @returns `val` as is if it's a valid A, throws if not.
function assertA(val/*: A*/, opts/*: ValidationOptions*/={})/*: A*/ {
    let ret = checkA(val, opts);
    assert(typeof ret === 'boolean');
    if (ret) {
        return val;
    } else {
        let errors/*: ?Array<ValidationErrorDesc>*/ = (checkA/*: any*/).errors;
        if (errors == null || errors.length === 0) {
            throw new Error('json validation failed');
        }
        throw new ValidationError("A", errors);
    }
};

// Checks whether `val` is a valid B.
function checkB(val/*: B*/, opts/*: ValidationOptions*/={})/*: boolean*/ {
    const ajv = opts.allErrors !== true ? ajvDefault : ajvAllErrors;
    const validators = opts.allErrors !== true ? g_validators : g_validatorsAllErrors;

    let validator = validators["B"];
    if (validator == null) {
        let schema = {
            "type": "object",
            "properties": {
                "arr": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "properties": {
                            "bool": {
                                "type": "boolean"
                            },
                            "num": {
                                "type": "number"
                            },
                            "numLit": {
                                "anyOf": [
                                    {
                                        "type": "number",
                                        "enum": [
                                            1
                                        ]
                                    },
                                    {
                                        "type": "number",
                                        "enum": [
                                            20
                                        ]
                                    }
                                ]
                            },
                            "numNull": {
                                "anyOf": [
                                    {
                                        "type": "null"
                                    },
                                    {
                                        "type": "number"
                                    }
                                ]
                            },
                            "numOpt": {
                                "type": "number"
                            },
                            "str": {
                                "type": "string"
                            },
                            "strLit": {
                                "anyOf": [
                                    {
                                        "type": "string",
                                        "enum": [
                                            "a"
                                        ]
                                    },
                                    {
                                        "type": "string",
                                        "enum": [
                                            "bc"
                                        ]
                                    }
                                ]
                            }
                        },
                        "required": [
                            "bool",
                            "num",
                            "numLit",
                            "numNull",
                            "str",
                            "strLit"
                        ],
                        "additionalProperties": false
                    }
                },
                "c": {
                    "anyOf": [
                        {
                            "type": "string"
                        },
                        {
                            "type": "number"
                        }
                    ]
                },
                "d": {
                    "anyOf": [
                        {
                            "type": "boolean"
                        },
                        {
                            "type": "null"
                        }
                    ]
                },
                "e": {
                    "anyOf": [
                        {
                            "type": "object",
                            "properties": {
                                "a": {
                                    "type": "number",
                                    "enum": [
                                        1
                                    ]
                                },
                                "b": {
                                    "type": "string"
                                }
                            },
                            "required": [
                                "a",
                                "b"
                            ],
                            "additionalProperties": false
                        },
                        {
                            "type": "object",
                            "properties": {
                                "a": {
                                    "type": "number",
                                    "enum": [
                                        2
                                    ]
                                },
                                "b": {
                                    "type": "number"
                                }
                            },
                            "required": [
                                "a",
                                "b"
                            ],
                            "additionalProperties": false
                        }
                    ]
                },
                "f": {
                    "type": "object",
                    "patternProperties": {
                        ".*": {
                            "anyOf": [
                                {
                                    "type": "number"
                                },
                                {
                                    "type": "string"
                                }
                            ]
                        }
                    },
                    "additionalProperties": false
                },
                "tuple": {
                    "type": "array",
                    "items": [
                        {
                            "type": "string"
                        },
                        {
                            "type": "number"
                        },
                        {
                            "anyOf": [
                                {
                                    "type": "number",
                                    "enum": [
                                        1
                                    ]
                                },
                                {
                                    "type": "number",
                                    "enum": [
                                        2
                                    ]
                                }
                            ]
                        }
                    ]
                }
            },
            "required": [
                "arr",
                "c",
                "d",
                "e",
                "f",
                "tuple"
            ],
            "additionalProperties": false
        };
        validator = ajv.compile(schema);
        validators["B"] = validator;
    }
    let ret/*: boolean*/ = validator(val);
    assert(typeof ret === 'boolean');
    let errors/*: ?Array<ValidationErrorDesc>*/ = (validator/*: any*/).errors;
    (checkB/*: any*/).errors = errors;
    return ret;
};

// Checks whether `val` is a valid B.
// @returns `val` as is if it's a valid B, throws if not.
function assertB(val/*: B*/, opts/*: ValidationOptions*/={})/*: B*/ {
    let ret = checkB(val, opts);
    assert(typeof ret === 'boolean');
    if (ret) {
        return val;
    } else {
        let errors/*: ?Array<ValidationErrorDesc>*/ = (checkB/*: any*/).errors;
        if (errors == null || errors.length === 0) {
            throw new Error('json validation failed');
        }
        throw new ValidationError("B", errors);
    }
};

// Checks whether `val` is a valid DoublyIndirectType3.
function checkDoublyIndirectType3(val/*: DoublyIndirectType3*/, opts/*: ValidationOptions*/={})/*: boolean*/ {
    const ajv = opts.allErrors !== true ? ajvDefault : ajvAllErrors;
    const validators = opts.allErrors !== true ? g_validators : g_validatorsAllErrors;

    let validator = validators["DoublyIndirectType3"];
    if (validator == null) {
        let schema = {
            "type": "string",
            "enum": [
                "d"
            ]
        };
        validator = ajv.compile(schema);
        validators["DoublyIndirectType3"] = validator;
    }
    let ret/*: boolean*/ = validator(val);
    assert(typeof ret === 'boolean');
    let errors/*: ?Array<ValidationErrorDesc>*/ = (validator/*: any*/).errors;
    (checkDoublyIndirectType3/*: any*/).errors = errors;
    return ret;
};

// Checks whether `val` is a valid DoublyIndirectType3.
// @returns `val` as is if it's a valid DoublyIndirectType3, throws if not.
function assertDoublyIndirectType3(val/*: DoublyIndirectType3*/, opts/*: ValidationOptions*/={})/*: DoublyIndirectType3*/ {
    let ret = checkDoublyIndirectType3(val, opts);
    assert(typeof ret === 'boolean');
    if (ret) {
        return val;
    } else {
        let errors/*: ?Array<ValidationErrorDesc>*/ = (checkDoublyIndirectType3/*: any*/).errors;
        if (errors == null || errors.length === 0) {
            throw new Error('json validation failed');
        }
        throw new ValidationError("DoublyIndirectType3", errors);
    }
};

// Checks whether `val` is a valid IA_exported.
function checkIA_exported(val/*: IA_exported*/, opts/*: ValidationOptions*/={})/*: boolean*/ {
    const ajv = opts.allErrors !== true ? ajvDefault : ajvAllErrors;
    const validators = opts.allErrors !== true ? g_validators : g_validatorsAllErrors;

    let validator = validators["IA_exported"];
    if (validator == null) {
        let schema = {
            "type": "object",
            "properties": {
                "fdd": {
                    "type": "object",
                    "patternProperties": {
                        ".*": {
                            "anyOf": [
                                {
                                    "type": "number"
                                },
                                {
                                    "type": "string"
                                }
                            ]
                        }
                    },
                    "additionalProperties": false
                }
            },
            "required": [
                "fdd"
            ],
            "additionalProperties": false
        };
        validator = ajv.compile(schema);
        validators["IA_exported"] = validator;
    }
    let ret/*: boolean*/ = validator(val);
    assert(typeof ret === 'boolean');
    let errors/*: ?Array<ValidationErrorDesc>*/ = (validator/*: any*/).errors;
    (checkIA_exported/*: any*/).errors = errors;
    return ret;
};

// Checks whether `val` is a valid IA_exported.
// @returns `val` as is if it's a valid IA_exported, throws if not.
function assertIA_exported(val/*: IA_exported*/, opts/*: ValidationOptions*/={})/*: IA_exported*/ {
    let ret = checkIA_exported(val, opts);
    assert(typeof ret === 'boolean');
    if (ret) {
        return val;
    } else {
        let errors/*: ?Array<ValidationErrorDesc>*/ = (checkIA_exported/*: any*/).errors;
        if (errors == null || errors.length === 0) {
            throw new Error('json validation failed');
        }
        throw new ValidationError("IA_exported", errors);
    }
};

// Checks whether `val` is a valid IB_exported.
function checkIB_exported(val/*: IB_exported*/, opts/*: ValidationOptions*/={})/*: boolean*/ {
    const ajv = opts.allErrors !== true ? ajvDefault : ajvAllErrors;
    const validators = opts.allErrors !== true ? g_validators : g_validatorsAllErrors;

    let validator = validators["IB_exported"];
    if (validator == null) {
        let schema = {
            "type": "object",
            "properties": {
                "zf": {
                    "type": "number",
                    "enum": [
                        3
                    ]
                }
            },
            "required": [
                "zf"
            ],
            "additionalProperties": false
        };
        validator = ajv.compile(schema);
        validators["IB_exported"] = validator;
    }
    let ret/*: boolean*/ = validator(val);
    assert(typeof ret === 'boolean');
    let errors/*: ?Array<ValidationErrorDesc>*/ = (validator/*: any*/).errors;
    (checkIB_exported/*: any*/).errors = errors;
    return ret;
};

// Checks whether `val` is a valid IB_exported.
// @returns `val` as is if it's a valid IB_exported, throws if not.
function assertIB_exported(val/*: IB_exported*/, opts/*: ValidationOptions*/={})/*: IB_exported*/ {
    let ret = checkIB_exported(val, opts);
    assert(typeof ret === 'boolean');
    if (ret) {
        return val;
    } else {
        let errors/*: ?Array<ValidationErrorDesc>*/ = (checkIB_exported/*: any*/).errors;
        if (errors == null || errors.length === 0) {
            throw new Error('json validation failed');
        }
        throw new ValidationError("IB_exported", errors);
    }
};

module.exports = {
    ValidationError,
    checkA,
    assertA,
    checkB,
    assertB,
    checkDoublyIndirectType3,
    assertDoublyIndirectType3,
    checkIA_exported,
    assertIA_exported,
    checkIB_exported,
    assertIB_exported,
};